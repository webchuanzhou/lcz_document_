<!--
 * @Author: lcz
 * @Date: 2021-12-30 11:11:34
 * @LastEditTime: 2022-01-05 09:48:11
 * @LastEditors: Please set LastEditors
 * @Description: 打开koroFileHeader查看配置 进行设置: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE
 * @FilePath: \lcz_document\docs\study\blockChain.md
-->

### 去中心化

> 淘宝微信都是中心化的，因为存数据到数据库里，不能共用
> 去中心化就是 账号在链上，多个网站都可以用，用 web3 在都安装的 metamask 链接钱包,去中心化的世界是没有服务器的，用户自己保存自己的数据

### 去中心化的 ID（DID）

> 在链上的 Id
> 类似于

```html
did:example:123456789abcdefghi
```

> 每一个 DID 都有自己的一个公钥，也一起存放到链上，用户可以用私钥来进行认证和授权。
> 中心化的方式下，用户根本没有必要待在 App 里面，每次我需要一个执行某个操作，只需要出示我的签名即可，用签名向 DApp 其它参与者证明我是有某项权力的。类似的，授权过程也是通过私钥签名来完成的，例如，我要允许哪些朋友查看我的帖子，哪些人可以编辑我的文档等等，这些都是可以实现的。以上就是，去中心化 ID 的基本原理了。

## 区块链特征

1. p2p 网络路由， 点对点，用户对用户（传递的方式）每个人都是信息的接收者，也是信息的传递者
2. 分布式账本 （人人手上都有同步的账本）
3. 共识机制 （选一个用户进行打包，有费用）
4. 难以篡改（要改只能把所有节点的账本都改了，所有用户，不太现实）

## 交易原理

1. 实际在签名之前，会先对交易信息进行 Hash 运算得到摘要信息，然后对摘要信息进行签名

```js
hash('
    {"付款地址"："2A39CBa2390FDe",
    "收款地址"："AAC9CBa239aFcc",
    "金额"："0.2btc"
    }')
```

2. 用私钥对交易摘要进行签名

```js
sign("8aDB23CDEA6", "J78sknJhidhLIqdngalket") -> "3cdferdadgadg"
```

3. 广播给其他节点
4. 节点在收到广播信息之后，会验证签名信息是不是付款方用私钥对交易原始信息签名产生的，如果验证通过说明确实是付款方本人发出的交易，说明交易有效，才会记录到账本中去。
5. 验证过程实际是签名过程的逆运算

```js
verify("3cdferdadgadg", "2A39CBa2390FDe") -> "8aDB23CDEA6"
```

6. 如果验证输出的信息和原始交易信息的 hash 一致，则验证通过，记录账本，用代码表示大概是这样：

```js
if(verify("3cdferdadgadg", "2A39CBa2390FDe")
    == hash('{"付款地址"："2A39CBa2390FDe",
              "收款地址"："AAC9CBa239aFcc",
              "金额"："0.2btc"}')) :
    // 写入账本
    // 广播
else:
```

## 挖矿的原理

我们了解到记账是把交易记录、交易时间、账本序号、上一个 Hash 值等信息计算 Hash 打包的过程。 我们知道所有的计算和存贮是需要消耗计算机资源的，既然要付出成本，那节点为什么还要参与记账呢？在中本聪（比特币之父）的设计里，完成记账的节点可以获得系统给与的一定数量的比特币奖励，这个奖励的过程也就是比特币的发行过程，因此大家形象的把记账称为“挖矿”

1. 一段时间内（10 分钟左右，具体时间会与密码学难题难度相互影响）只有一人可以记账成功
2. 通过解决密码学难题（即工作量证明）竞争获得唯一记账权
3. 其他节点复制记账结果
   > 不过在进行工作量证明之前，记账节点会做进行如下准备工作：
4. 收集广播中还没有被记录账本的原始交易信息
5. 检查每个交易信息中付款地址有没有足够的余额
6. 验证交易是否有正确的签名
7. 把验证通过的交易信息进行打包记录
8. 添加一个奖励交易：给自己的地址增加 12.5 比特币
   如果节点争夺记账权成功的话，就可以得到 12.5 比特币的奖励。

> 为什么挖矿难度大
> Hash 值是由数字和大小写字母构成的字符串，每一位有 62 种可能性（可能为 26 个大写字母、26 个小写字母，10 个数字中任一个），假设任何一个字符出现的概率是均等的，那么第一位为 0 的概率是 1/62（其他位出现什么字符先不管），理论上需要尝试 62 次 Hash 运算才会出现一次第一位为 0 的情况，如果前两 2 位为 0，就得尝试 62 的平方次 Hash 运算，以 n 个 0 开头就需要尝试 62 的 n 次方次运算。

## 拜占庭将军

就是（分布式系统一致性问题），

> 经济学分析
> 工作量证明其实相当于提高了做叛徒（发布虚假区块）的成本，在工作量证明下，只有第一个完成证明的节点才能广播区块，竞争难度非常大，需要很高的算力，如果不成功其算力就白白的耗费了（算力是需要成本的），如果有这样的算力作为诚实的节点，同样也可以获得很大的收益（这就是矿工所作的工作），这也实际就不会有做叛徒的动机，整个系统也因此而更稳定。

## 以太坊网络
选择以太坊官网测试网络Testnet
测试网络中，我们可以很容易获得免费的以太币，缺点是需要发很长时间初始化节点。

使用私有链
创建自己的以太币私有测试网络，通常也称为私有链，我们可以用它来作为一个测试环境来开发、调试和测试智能合约。
通过上面提到的Geth很容易就可以创建一个属于自己的测试网络，以太币想挖多少挖多少，也免去了同步正式网络的整个区块链数据。

使用开发者网络(模式)
相比私有链，开发者网络(模式)下，会自动分配一个有大量余额的开发者账户给我们使用。

使用模拟环境
另一个创建测试网络的方法是使用Ganache，Ganache是普通的应用程序，它在本地使用内存模拟的一个以太坊区块链环境，对于开发调试来说，更方便快捷。而且Ganache会在启动时帮我们创建10个存有资金的测试账户。
进行合约开发时，可以在Ganache中测试通过后，再部署到Geth节点中去。